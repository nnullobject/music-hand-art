<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <title>Gemini Nebula - Sharp Edition</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        #ui { position: absolute; top: 30px; left: 30px; color: #fff; pointer-events: none; text-shadow: 0 0 5px rgba(0,0,0,0.9); }
        h1 { margin: 0; font-weight: 100; letter-spacing: 4px; font-size: 24px; color: #aaaaff; }
        .status-box { background: rgba(0,0,0,0.3); padding: 10px 15px; border: 1px solid rgba(255,255,255,0.1); border-radius: 4px; margin-top: 10px; }
        p { margin: 5px 0; font-size: 14px; color: #ccc; }
        canvas { display: block; }
    </style>
</head>
<body>
    <div id="ui">
        <h1>GEMINI NEBULA / SHARP</h1>
        <div class="status-box">
            <p>狀態：<span id="status">點擊畫面以啟動音頻與權限</span></p>
            <p>手勢：<span id="hand-pos">等待偵測...</span></p>
        </div>
    </div>

    <script src="https://cdn.jsdelivr.net/npm/three@0.150.0/build/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>

    <script id="vertexShader" type="x-shader/x-vertex">
        uniform float uTime;
        uniform float uAudioHigh;
        uniform vec3 uHandPos;
        attribute float aSize;
        attribute float aIndex;
        varying vec3 vColor;

        // 簡單的隨機函數，用於增加粒子的離散感
        float hash(float n) { return fract(sin(n) * 43758.5453123); }

        void main() {
            // 調整幾何參數：讓環更大、更寬、更散
            float radiusBase = 5.0;  // 增大基礎半徑 (原本是3.0)
            float stripWidth = 2.5;  // 增大條帶寬度 (原本是1.2)
            
            float u = (aIndex / 50000.0) * 6.28318;
            float t = uTime * 0.15; // 讓流動速度慢一點，更優雅
            
            // 加入一點隨機擾動，讓它不像完美的幾何體
            float noise = hash(aIndex) * 0.5;
            float v = sin(t + u * 2.0 + noise) * stripWidth;

            vec3 targetPos;
            // 莫比烏斯環參數方程
            targetPos.x = cos(u) * (radiusBase + v * cos(u * 0.5));
            targetPos.y = sin(u) * (radiusBase + v * cos(u * 0.5));
            targetPos.z = v * sin(u * 0.5) + (hash(aIndex + 10.0) - 0.5) * 2.0; // Z軸也拉開一點

            // --- 交互邏輯 ---
            float dist = distance(targetPos, uHandPos);
            // 修改引力曲線，讓它更像一個範圍場，而不是一個點
            float attraction = smoothstep(5.0, 0.5, dist) * 2.0; 
            vec3 dir = normalize(uHandPos - targetPos);
            
            // 音頻反應：高頻時粒子會向外炸裂
            vec3 finalPos = targetPos + dir * attraction + normalize(targetPos) * uAudioHigh * hash(aIndex) * 1.5;

            // --- 渲染設置 ---
            vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);

            // 【核心修改】極大縮小粒子尺寸常數 (500 -> 120)
            // 音頻反應也調小，避免瞬間變得太巨大
            gl_PointSize = aSize * (120.0 / -mvPosition.z) * (1.0 + uAudioHigh * 1.5);
            gl_Position = projectionMatrix * mvPosition;
            
            // 顏色映射：調整為更冷冽、深邃的星空配色
            float depth = smoothstep(-3.0, 3.0, finalPos.z);
            vColor = mix(vec3(0.0, 0.2, 0.8), vec3(0.8, 0.3, 1.0), depth);
            vColor += uAudioHigh * 0.8; // 音頻高光
        }
    </script>

    <script id="fragmentShader" type="x-shader/x-fragment">
        varying vec3 vColor;
        void main() {
            // 計算像素到粒子中心的距離
            float dist = length(gl_PointCoord - vec2(0.5));
            
            // 使用 smoothstep 創造銳利的邊緣，不再是模糊的一團
            // 邊緣從 0.5 到 0.3 快速衰減
            float strength = smoothstep(0.5, 0.3, dist);

            // 丟棄邊界外的像素
            if (strength <= 0.0) discard;
            
            // 降低整體透明度 (0.8)，這樣重疊時才會有層次感，不會變一片白
            gl_FragColor = vec4(vColor, strength * 0.8);
        }
    </script>

    <script>
        let scene, camera, renderer, particles;
        let audioAnalyser, dataArray;
        // 手勢初始位置放遠一點，避免一開始就干擾圖形
        const handPos = new THREE.Vector3(1000, 1000, 1000);

        async function init() {
            scene = new THREE.Scene();
            // 將相機拉遠一點，以便觀察更大的星雲
            camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            camera.position.z = 12; 

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(window.devicePixelRatio); // 確保在高解析度螢幕上清晰
            // 使用更適合星空的清除顏色 (深藍黑)
            renderer.setClearColor(0x020207, 1); 
            document.body.appendChild(renderer.domElement);

            const count = 50000;
            const geometry = new THREE.BufferGeometry();
            const positions = new Float32Array(count * 3);
            const sizes = new Float32Array(count);
            const indices = new Float32Array(count);

            for (let i = 0; i < count; i++) {
                indices[i] = i;
                // 讓粒子的基礎大小差異更大，增加層次感
                sizes[i] = Math.random() * 1.2 + 0.3;
            }

            geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
            geometry.setAttribute('aSize', new THREE.BufferAttribute(sizes, 1));
            geometry.setAttribute('aIndex', new THREE.BufferAttribute(indices, 1));

            const material = new THREE.ShaderMaterial({
                uniforms: {
                    uTime: { value: 0 },
                    uAudioHigh: { value: 0 },
                    uHandPos: { value: handPos }
                },
                vertexShader: document.getElementById('vertexShader').textContent,
                fragmentShader: document.getElementById('fragmentShader').textContent,
                transparent: true,
                // 保持加法混合，但因為粒子變小且透明度降低，不會再糊成一團
                blending: THREE.AdditiveBlending, 
                depthWrite: false
            });

            particles = new THREE.Points(geometry, material);
            scene.add(particles);

            // Mediapipe 設定
            const hands = new Hands({
                locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
            });
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5 });
            hands.onResults(onHandResults);

            const videoElement = document.createElement('video');
            // 降低一點攝影機解析度以提升效能
            const cameraUtils = new Camera(videoElement, {
                onFrame: async () => { await hands.send({image: videoElement}); },
                width: 640, height: 480 
            });
            cameraUtils.start();

            window.addEventListener('resize', onWindowResize);
            window.onclick = initAudio; // 點擊啟動音頻
            
            animate();
        }

        function onHandResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmark = results.multiHandLandmarks[0][8]; // 食指指尖
                // 調整映射範圍以配合新的場景大小
                handPos.x = (landmark.x - 0.5) * -20;
                handPos.y = (0.5 - landmark.y) * 20;
                // 使用 Z 座標讓手勢有前後深度感
                handPos.z = landmark.z * -15; 
                document.getElementById('hand-pos').innerText = `追蹤中: X:${handPos.x.toFixed(1)} Y:${handPos.y.toFixed(1)}`;
            } else {
                 // 手移開時，將引力點移到遠處，而不是讓它消失，這樣粒子會緩慢飄回原位
                handPos.lerp(new THREE.Vector3(100, 100, 100), 0.05);
                document.getElementById('hand-pos').innerText = `未偵測到手勢`;
            }
        }

        async function initAudio() {
            if (audioAnalyser) return;
            try {
                const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                const audioCtx = new AudioContext();
                const source = audioCtx.createMediaStreamSource(stream);
                audioAnalyser = audioCtx.createAnalyser();
                // 使用較小的 FFT size 來獲得更靈敏的高頻反應
                audioAnalyser.fftSize = 128; 
                source.connect(audioAnalyser);
                dataArray = new Uint8Array(audioAnalyser.frequencyBinCount);
                document.getElementById('status').innerText = '音頻分析運行中 (試著播放音樂)';
                // 成功後淡出 UI
                setTimeout(() => { document.getElementById('ui').style.opacity = 0.5; }, 2000);
            } catch (e) {
                document.getElementById('status').innerText = '錯誤：無法存取麥克風';
                console.error(e);
            }
        }

        function onWindowResize() {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function animate() {
            requestAnimationFrame(animate);
            const time = performance.now() * 0.001;
            particles.material.uniforms.uTime.value = time;

            if (audioAnalyser) {
                audioAnalyser.getByteFrequencyData(dataArray);
                // 抓取較高頻段的數據，並增加敏感度
                const highIndex = Math.floor(dataArray.length * 0.7); 
                particles.material.uniforms.uAudioHigh.value = dataArray[highIndex] / 255.0;
            }

            // 極其緩慢的整體旋轉，增加深邃感
            particles.rotation.y = time * 0.02;
            particles.rotation.z = sin(time * 0.05) * 0.1;
            renderer.render(scene, camera);
        }

        init();
    </script>
</body>
</html>
